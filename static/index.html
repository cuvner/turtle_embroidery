<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Embroidery Turtle Studio</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #22c55e;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --border: #1f2937;
      --mono: "IBM Plex Mono", ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
      --sans: "Space Grotesk", "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 20%, rgba(34,197,94,0.08), transparent 45%),
                  radial-gradient(circle at 80% 10%, rgba(14,165,233,0.1), transparent 40%),
                  radial-gradient(circle at 50% 80%, rgba(99,102,241,0.08), transparent 40%),
                  var(--bg);
      color: var(--text);
      font-family: var(--sans);
      display: flex;
      justify-content: center;
      padding: 32px 16px 64px;
      box-sizing: border-box;
    }
    .shell {
      width: min(1100px, 100%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    }
    .hero-img {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .hero-block {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    h1 {
      margin: 0 0 12px;
      font-size: 28px;
      letter-spacing: -0.03em;
    }
    p {
      margin: 0 0 16px;
      color: var(--muted);
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      gap: 16px;
    }
    .card {
      background: #0b1221;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: var(--muted);
    }
    input, textarea, button {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0a1220;
      color: var(--text);
      font-family: var(--mono);
      font-size: 14px;
      padding: 10px 12px;
      box-sizing: border-box;
    }
    textarea {
      min-height: 280px;
      resize: vertical;
      line-height: 1.4;
    }
    button {
      cursor: pointer;
      background: linear-gradient(120deg, var(--accent), #16a34a);
      color: #052e16;
      font-weight: 700;
      border: none;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 30px rgba(34,197,94,0.25);
    }
    .row {
      display: flex;
      gap: 8px;
    }
    .row button {
      flex: 1;
      background: #0a1628;
      color: var(--text);
      border: 1px solid var(--border);
      box-shadow: none;
      font-weight: 600;
    }
    .row button.primary {
      background: linear-gradient(120deg, var(--accent), #16a34a);
      color: #052e16;
      border: none;
    }
    .status {
      font-family: var(--mono);
      font-size: 13px;
      color: var(--muted);
      min-height: 20px;
    }
    .downloads a {
      color: var(--accent);
      font-weight: 700;
      text-decoration: none;
    }
    .downloads {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 14px;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal {
      background: #0b1221;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      width: min(720px, 90vw);
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text);
      margin-bottom: 8px;
    }
    #previewCanvas {
      width: 100%;
      height: 400px;
      background: #0a0f1c;
      border: 1px solid var(--border);
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div class="shell">
    <h1>Embroidery Turtle Studio</h1>
    <p>Write a simple turtle script and export PES/PNG for a 150 cm hoop (10 mm per unit). This project lets students turn basic turtle code into real embroidery files, bridging coding and fabric.</p>
    <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:flex-start; margin-bottom:12px;">
      <div style="flex:2; min-width:260px; color: var(--muted); font-size:14px; line-height:1.5;">
        <strong>Steps:</strong>
        <ol style="margin:6px 0 8px 18px; padding:0; color: var(--text);">
          <li>Load the sample octagon.</li>
          <li>Edit the turtle script (stay within 150 units).</li>
          <li>Click “Run script → PES/PNG”.</li>
          <li>Download PES and PNG for your machine.</li>
        </ol>
        <strong>Available commands:</strong>
        <ul style="margin:6px 0 0 18px; padding:0; color: var(--text);">
          <li>forward(x), backward(x)</li>
          <li>left(deg), right(deg)</li>
          <li>penup(), pendown()</li>
          <li>goto(x, y)</li>
          <li>for i in range(N): (indent commands below)</li>
        </ul>
      </div>
      <div style="flex:0 0 330px; height:186px; position:relative; overflow:hidden; border-radius:10px; border:1px solid var(--border); box-shadow:0 6px 20px rgba(0,0,0,0.25);">
        <iframe width="330" height="186" src="https://www.youtube.com/embed/9y6Es6l52Us?si=Uq7KV-W8EGiAhkpw" title="Embroidery machine tutorial" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="position:absolute; top:0; left:0; width:100%; height:100%; border:0;"></iframe>
      </div>
    </div>
    <div class="grid">
      <div class="card">
        <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start;">
          <img src="/images/turtle_embroider.png" alt="Embroidery turtle example" class="hero-img" style="max-width:260px; min-width:200px; flex:1;">
          <div style="flex:2; min-width:240px;">
            <label>Script (basic turtle)</label>
            <textarea id="script"></textarea>
          </div>
        </div>
        <div class="row">
          <button id="loadScript" type="button">Load sample octagon</button>
          <button id="exportScript" class="primary" type="button">Run script → PES/PNG</button>
          <button id="previewBtn" type="button">Preview</button>
        </div>
        <div class="status" id="status"></div>
        <div class="downloads" id="downloads"></div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="previewModal">
    <div class="modal">
      <div class="modal-header">
        <div>Preview</div>
        <button id="closePreview" type="button" style="width:auto; padding:6px 10px;">Close</button>
      </div>
      <canvas id="previewCanvas"></canvas>
      <div class="status" id="previewStatus"></div>
    </div>
  </div>

  <script>
    const scriptInput = document.getElementById('script');
    const statusEl = document.getElementById('status');
    const downloadsEl = document.getElementById('downloads');
    const previewBtn = document.getElementById('previewBtn');
    const previewModal = document.getElementById('previewModal');
    const closePreview = document.getElementById('closePreview');
    const previewCanvas = document.getElementById('previewCanvas');
    const previewStatus = document.getElementById('previewStatus');

    const defaultScale = 10;
    const defaultMaxStitch = 3;

    const sampleScript = `# Octagon: 8 sides, turn 45° each step
penup()
goto(65, 85)
pendown()
for i in range(8):
    forward(20)
    right(45)
`;
    scriptInput.value = sampleScript;

    document.getElementById('loadScript').addEventListener('click', () => {
      scriptInput.value = sampleScript;
      statusEl.textContent = 'Loaded sample octagon.';
      downloadsEl.innerHTML = '';
    });

    const enableTabIndent = (el) => {
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = el.selectionStart;
          const end = el.selectionEnd;
          const value = el.value;
          el.value = value.substring(0, start) + '    ' + value.substring(end);
          el.selectionStart = el.selectionEnd = start + 4;
        }
      });
    };

    enableTabIndent(scriptInput);

    const enableAutoIndentAfterColon = (el) => {
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const pos = el.selectionStart;
          const value = el.value;
          const prevNewline = value.lastIndexOf('\n', pos - 1);
          const lineStart = prevNewline === -1 ? 0 : prevNewline + 1;
          const line = value.slice(lineStart, pos);
          const indentMatch = line.match(/^\s*/);
          const baseIndent = indentMatch ? indentMatch[0] : '';
          const extraIndent = line.trimEnd().endsWith(':') ? '    ' : '';
          if (extraIndent) {
            e.preventDefault();
            const insert = '\n' + baseIndent + extraIndent;
            el.value = value.slice(0, pos) + insert + value.slice(el.selectionEnd);
            const newPos = pos + insert.length;
            el.selectionStart = el.selectionEnd = newPos;
          }
        }
      });
    };

    enableAutoIndentAfterColon(scriptInput);

    const b64ToBlob = (b64, mime) => {
      const byteChars = atob(b64);
      const byteNumbers = new Array(byteChars.length);
      for (let i = 0; i < byteChars.length; i++) {
        byteNumbers[i] = byteChars.charCodeAt(i);
      }
      return new Blob([new Uint8Array(byteNumbers)], { type: mime });
    };

    const setStatus = (msg) => {
      statusEl.textContent = msg;
    };

    const renderDownloads = (pesB64, pngB64) => {
      const pesBlob = b64ToBlob(pesB64, 'application/octet-stream');
      const pngBlob = b64ToBlob(pngB64, 'image/png');
      const pesUrl = URL.createObjectURL(pesBlob);
      const pngUrl = URL.createObjectURL(pngBlob);
      downloadsEl.innerHTML = '';

      const pesLink = document.createElement('a');
      pesLink.href = pesUrl;
      pesLink.download = 'design.pes';
      pesLink.textContent = 'Download PES';

      const pngLink = document.createElement('a');
      pngLink.href = pngUrl;
      pngLink.download = 'design.png';
      pngLink.textContent = 'Download PNG';

      downloadsEl.appendChild(pesLink);
      downloadsEl.appendChild(document.createTextNode(' '));
      downloadsEl.appendChild(pngLink);
    };

    document.getElementById('exportScript').addEventListener('click', async () => {
      setStatus('Running script…');
      downloadsEl.innerHTML = '';

      const payload = {
        script: scriptInput.value,
        scale_mm: defaultScale,
        max_stitch_mm: defaultMaxStitch,
      };

      try {
        const res = await fetch('/export_script', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.detail || 'Request failed');
        }
        const data = await res.json();
        renderDownloads(data.pes_base64, data.png_base64);
        setStatus(`Ready from script. Stitches: ${data.stitch_count}`);
      } catch (err) {
        setStatus('Error: ' + err.message);
      }
    });

    // Preview modal + animation
    let animationFrame = null;
    let animationTimer = null;

    const buildSegments = (commands) => {
      const segments = [];
      let x = 0;
      let y = 0;
      let heading = 0;
      let penDown = false;

      commands.forEach(cmd => {
        const op = (cmd.op || '').toLowerCase();
        const val = Number(cmd.value || 0);
        if (op === 'penup') {
          penDown = false;
        } else if (op === 'pendown') {
          penDown = true;
        } else if (op === 'goto') {
          const nx = Number(cmd.x || 0);
          const ny = Number(cmd.y || 0);
          if (penDown) segments.push({ from: [x, y], to: [nx, ny] });
          x = nx; y = ny;
        } else if (op === 'forward' || op === 'backward') {
          const distance = op === 'forward' ? val : -val;
          const rad = heading * Math.PI / 180;
          const nx = x + Math.cos(rad) * distance;
          const ny = y + Math.sin(rad) * distance;
          if (penDown) segments.push({ from: [x, y], to: [nx, ny] });
          x = nx; y = ny;
        } else if (op === 'left') {
          heading += val;
        } else if (op === 'right') {
          heading -= val;
        }
      });

      return segments;
    };

    const drawAnimated = (segments) => {
      const ctx = previewCanvas.getContext('2d');
      const w = previewCanvas.width;
      const h = previewCanvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;

      const GRID = 150;
      const padding = 20;
      const scale = Math.min((w - 2 * padding) / GRID, (h - 2 * padding) / GRID);
      const toCanvas = (tx, ty) => {
        const cx = padding + tx * scale;
        const cy = h - (padding + ty * scale);
        return [cx, cy];
      };

      if (animationFrame) cancelAnimationFrame(animationFrame);
      if (animationTimer) clearInterval(animationTimer);

      let i = 0;
      animationTimer = setInterval(() => {
        if (i >= segments.length) {
          clearInterval(animationTimer);
          animationTimer = null;
          return;
        }
        const seg = segments[i];
        const [fx, fy] = toCanvas(seg.from[0], seg.from[1]);
        const [tx, ty] = toCanvas(seg.to[0], seg.to[1]);
        ctx.beginPath();
        ctx.moveTo(fx, fy);
        ctx.lineTo(tx, ty);
        ctx.stroke();
        i += 1;
      }, 60);
    };

    const openPreview = (commands) => {
      previewModal.style.display = 'flex';
      previewStatus.textContent = 'Previewing…';
      const rect = previewCanvas.getBoundingClientRect();
      previewCanvas.width = rect.width;
      previewCanvas.height = rect.height;
      const segments = buildSegments(commands);
      drawAnimated(segments);
      previewStatus.textContent = `Preview ready (segments: ${segments.length})`;
    };

    closePreview.addEventListener('click', () => {
      previewModal.style.display = 'none';
      if (animationFrame) cancelAnimationFrame(animationFrame);
      if (animationTimer) clearInterval(animationTimer);
    });

    previewModal.addEventListener('click', (e) => {
      if (e.target === previewModal) {
        previewModal.style.display = 'none';
        if (animationFrame) cancelAnimationFrame(animationFrame);
        if (animationTimer) clearInterval(animationTimer);
      }
    });

    previewBtn.addEventListener('click', async () => {
      previewStatus.textContent = '';
      setStatus('Preparing preview…');
      try {
        const res = await fetch('/export_script', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            script: scriptInput.value,
            scale_mm: defaultScale,
            max_stitch_mm: defaultMaxStitch,
          }),
        });
        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.detail || 'Request failed');
        }
        const data = await res.json();
        openPreview(data.commands);
        setStatus('Preview ready.');
      } catch (err) {
        setStatus('Preview error: ' + err.message);
      }
    });
  </script>
</body>
</html>
